import 'dart:async';

import 'package:connectycube_sdk/connectycube_sdk.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import 'package:handjob_mobile/app/app.router.dart';
import 'package:handjob_mobile/main.dart';
import 'package:handjob_mobile/managers/call_manager.dart';
import 'package:handjob_mobile/services/shared.service.dart';
import 'package:stacked/stacked.dart';
import 'package:stacked_services/stacked_services.dart';

import '../../app/app.locator.dart';
import '../../models/user.model.dart';
import '../../services/authentication.service.dart';
import '../../services/notification.service.dart';
import '../../services/post.service.dart';
import '../../services/video-call.service.dart';

class MainViewModel extends ReactiveViewModel {
  final _navigationService = locator<NavigationService>();
  final _authenticationService = locator<AuthenticationService>();
  final _sharedService = locator<SharedService>();
  final _postService = locator<PostService>();
  final _videoCallService = locator<VideoCallService>();
  final _notificationService = locator<NotificationService>();
  final DeviceInfoPlugin deviceInfo = DeviceInfoPlugin();

  // IO.Socket get videoSocket => _videoCallService.socket;

  int get currentIndex => _sharedService.currentIndex;

  User? get currentUser => _authenticationService.currentUser;

  navigateToProfile() => _navigationService.navigateTo(Routes.profileView);

  void initializeView() async {
    // _videoCallService.initSocket();
    //update device token
    String? token = await messaging.getToken();
    if (token != null && currentUser != null) {
      // print("device registration token: $token");
      // print(" current user: ${currentUser?.toJson()}");
      Map formData = {
        "userId": currentUser?.id,
        "deviceToken": token,
        "platform": "mobile"
      };
      if (defaultTargetPlatform == TargetPlatform.android) {
        AndroidDeviceInfo info = await deviceInfo.androidInfo;
        formData['deviceName'] = info.device;
      } else if (defaultTargetPlatform == TargetPlatform.iOS) {
        IosDeviceInfo info = await deviceInfo.iosInfo;
        formData['deviceName'] = info.name;
      } else {
        print('other devices');
        final info = await deviceInfo.deviceInfo;
        print('info json: ${info.data}');
      }
      print('formdata: $formData');
      try {
        await _authenticationService.updateDeviceToken(formData);
      } catch (e) {}
    }
  }

  @override
  dispose() {
    // videoSocket.dispose();
    // videoSocket.disconnect();
  }

  setCurrentIndex(int value) {
    _sharedService.setCurrentIndex(value);
    notifyListeners();
  }

  Future<void> fetchCountries() async {
    try {
      await _sharedService.getCountries();
    } on DioError {}
  }

  Future<void> fetchStates() async {
    try {
      await _sharedService.getStates();
    } on DioError {}
  }

  Future<void> fetchLGA() async {
    try {
      await _sharedService.getLGA();
    } on DioError {}
  }

  Future<void> fetchQualification() async {
    try {
      await _sharedService.getQualification();
    } on DioError {}
  }

  Future<void> fetchProfessionTypes() async {
    try {
      await _sharedService.getProfessionTypes();
    } on DioError {}
  }

  fetchPost() {
    runBusyFuture(
      fetchPostRequest(),
    );
  }

  fetchPostRequest() async {
    try {
      await _postService.getPosts();
    } finally {
      notifyListeners();
    }
  }

  fetchNotification() async {
    try {
      // await _notificationService.getNotifications();
      await _notificationService.getAccountNotifications(currentUser!.id!);
    } on DioError {}
  }

  @override
  List<ReactiveServiceMixin> get reactiveServices => [_sharedService];

  void navigateBack() => _navigationService.back();

  Future<void> logout() async {
    await _authenticationService.logout();
    _navigationService.replaceWith(Routes.authView);
  }

  void navigateToHelpAndSupport() =>
      _navigationService.navigateTo(Routes.helpAndSupportView);

  void navigateToFAQs() => _navigationService.navigateTo(Routes.fAQsView);

  void navigateToSettings() =>
      _navigationService.navigateTo(Routes.settingView);

  void navigateToContacts() =>
      _navigationService.navigateTo(Routes.contactView);

  void navigateToConnectionRequests() {}

  // initialize zego cloud sdk
  final List<StreamSubscription> subscriptions = [];
  initZegoCloudSdk() async {
    // await ZEGOSDKManager.instance.init(ZEGO_APP_ID, ZEGO_APP_SIGNATURE);
    // String? token;
    // if (kIsWeb) {
    //   // ! ** Warning: ZegoTokenUtils is only for use during testing. When your application goes live,
    //   // ! ** tokens must be generated by the server side. Please do not generate tokens on the client side!
    //   token = ZegoTokenUtils.generateToken(
    //      ZEGO_APP_ID, ZEGO_SERVER_SECRET_KEY, currentUser?.id ?? "");
    // }
    // String name = '${currentUser?.firstName} ${currentUser?.lastName}';
    // print('current info ${currentUser?.id ?? ""}, $name, token: $ZEGO_TEMPORARY_TOKEN,');
    // await ZEGOSDKManager.instance.connectUser(
    //   currentUser?.id ?? "",
    //   name,
    //   token: ZEGO_TEMPORARY_TOKEN,
    // );

    // subscriptions.addAll([
    //   ZEGOSDKManager.instance.zimService.connectionStateStreamCtrl.stream
    //       .listen((ZIMServiceConnectionStateChangedEvent event) {
    //     debugPrint('connectionStateStreamCtrl: $event');
    //     if (event.state == ZIMConnectionState.connected) {
    //       print('ZIM connection state: $event');
    //     }
    //   }),
    // ]);
  }

  void disconnectZegoCloudSdk() {
    // for (var subscription in subscriptions) {
    //   subscription.cancel();
    // }
  }

  // void onZegoUserConnect() {
  //   _videoCallService.onZegoUserConnect(currentUser);
  // }

  // void onZegoUserDisconnect() {
  //   _videoCallService.onZegoUserDisconnect();
  // }
  void onConnectCubeUser(User currentUser) async {
    log('onConnectCubeUser: $currentUser', 'ConnectCube');
    var name = "${currentUser.firstName} ${currentUser.lastName}";
    print('session state: ${CubeSessionManager.instance.activeSession}');
    // if(CubeSessionManager.instance.isActiveSessionValid()) return;
      CubeUser cubeUser = CubeUser(
        // isGuest: true,
        // id: 123,
        login: currentUser.id,
        fullName: name,
        email: currentUser.email,
        avatar: currentUser.imageUrl,

        customData: currentUser.id,
        password: "DEFAULT_PASS",
        
      );
    try {
      var response = await createSession();
// CubeSessionManager.instance.setToken(response.token!);
var foundCubeUser = await getUserByLogin(currentUser.id!);
      if (foundCubeUser != null) {
        await signIn(cubeUser);
      } else {
        await signUp(cubeUser);
      }
      print('logged in cubeuser: $foundCubeUser');
    } catch (e) {
      //if user is not found, sign up
      print('sign up user in exception');
      await signUp(cubeUser);
      print('exception: $e');
    }
  }

  void onDisconnectCubeUser() async {
    try {
      await signOut();
    } catch (e) {
      print('error destroying session: $e');
    }
  }
}
